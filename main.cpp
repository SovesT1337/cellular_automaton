/**
 * ====================================================================
 * ГЛАВНЫЙ ФАЙЛ: БЕНЧМАРК И ТЕСТИРОВАНИЕ
 * ====================================================================
 * 
 * Этот файл содержит:
 * 1. Функцию генерации случайных начальных состояний
 * 2. Систему бенчмаркинга CPU vs CUDA
 * 3. Сохранение результатов в CSV формате
 * 4. Главную функцию main() для запуска тестов
 * 
 * Цель программы:
 * - Сравнить производительность CPU и CUDA реализаций
 * - Проверить корректность CUDA версии
 * - Найти "точку перелома" (где CUDA становится быстрее CPU)
 * - Построить графики зависимости времени от размера графа
 */

#include "cellular_automaton.h"
#include <iostream>
#include <iomanip>
#include <random>
#include <vector>
#include <fstream>

// ====================================================================
// ГЕНЕРАЦИЯ СЛУЧАЙНОГО НАЧАЛЬНОГО СОСТОЯНИЯ
// ====================================================================
/**
 * Создаёт случайный вектор из 0 и 1 для инициализации автомата.
 * 
 * Параметры:
 * - n: количество элементов (узлов)
 * - seed: зерно для генератора (для воспроизводимости)
 * 
 * Возвращает: вектор размера n, где каждый элемент - 0 или 1
 * 
 * Использование seed позволяет:
 * - Получить одинаковые результаты при повторных запусках
 * - Корректно сравнить CPU и CUDA версии
 * - Воспроизвести любой тест
 */
std::vector<uint8_t> random_state(int n, unsigned int seed = 123) {
    std::mt19937 rng(seed);  // Mersenne Twister генератор
    std::uniform_int_distribution<int> dist(0, 1);  // Равномерное распределение 0 или 1
    std::vector<uint8_t> state(n);
    for (int i = 0; i < n; i++) {
        state[i] = dist(rng);  // Случайный бит
    }
    return state;
}

// ====================================================================
// СТРУКТУРА ДЛЯ ХРАНЕНИЯ РЕЗУЛЬТАТОВ БЕНЧМАРКА
// ====================================================================
/**
 * Содержит всю информацию о результатах одного теста:
 * 
 * Параметры теста:
 * - num_nodes: размер графа (количество узлов)
 * - num_edges: количество рёбер
 * - steps: количество шагов эволюции
 * - feedback_type: тип функции (0=XOR, 1=MAJORITY)
 * - feedback_name: имя функции (для отчётов)
 * 
 * Результаты:
 * - cpu_time_ms: время CPU в миллисекундах
 * - cuda_time_ms: время CUDA в миллисекундах
 * - speedup: ускорение CUDA (cpu_time / cuda_time)
 * - results_match: совпадают ли результаты CPU и CUDA
 */
struct BenchmarkResult {
    int num_nodes;              // Количество узлов в графе
    int num_edges;              // Количество рёбер в графе
    int steps;                  // Количество шагов симуляции
    int feedback_type;          // Тип функции обратной связи
    const char* feedback_name;  // Имя функции (для вывода)
    double cpu_time_ms;         // Время выполнения на CPU (мс)
    double cuda_time_ms;        // Время выполнения на CUDA (мс)
    double speedup;             // Ускорение: cpu_time / cuda_time
    bool results_match;         // Совпадают ли результаты
};

// ====================================================================
// ФУНКЦИЯ БЕНЧМАРКА ДЛЯ ОДНОГО РАЗМЕРА ГРАФА
// ====================================================================
/**
 * Выполняет полный цикл тестирования для графа заданного размера:
 * 1. Генерирует случайный граф
 * 2. Создаёт случайное начальное состояние
 * 3. Настраивает выходную последовательность
 * 4. Запускает на CPU
 * 5. Запускает на CUDA (если доступно)
 * 6. Сравнивает результаты
 * 7. Вычисляет ускорение
 * 
 * Параметры:
 * - num_nodes: количество узлов в графе
 * - avg_degree: средняя степень узла
 * - steps: количество шагов эволюции
 * - feedback_type: тип функции (0=XOR, 1=MAJORITY)
 * - feedback_name: имя функции для отчёта
 * 
 * Возвращает: BenchmarkResult со всеми метриками
 */
BenchmarkResult benchmark_graph_size(int num_nodes, int avg_degree, int steps, 
                                      int feedback_type, const char* feedback_name) {
    BenchmarkResult result;
    result.num_nodes = num_nodes;
    result.steps = steps;
    result.feedback_type = feedback_type;
    result.feedback_name = feedback_name;
    
    // ====================================================================
    // ГЕНЕРАЦИЯ ТЕСТОВЫХ ДАННЫХ
    // ====================================================================
    /**
     * Используем фиксированные seed'ы для воспроизводимости:
     * - seed=42 для графа
     * - seed=123 для начального состояния (по умолчанию)
     */
    Graph graph = generate_random_graph(num_nodes, avg_degree, 42);
    result.num_edges = graph.num_edges;
    
    // Генерируем случайное начальное состояние
    auto initial = random_state(num_nodes);
    
    // ====================================================================
    // НАСТРОЙКА ВЫХОДНОЙ ПОСЛЕДОВАТЕЛЬНОСТИ
    // ====================================================================
    /**
     * Извлекаем биты из первых 5 ячеек (0, 1, 2, 3, 4).
     * Частота извлечения: каждые steps/10 шагов (или 1, если steps < 10).
     * 
     * Это позволяет:
     * - Проверить корректность CUDA (сравнение с CPU)
     * - Не хранить все состояния (экономия памяти)
     */
    OutputConfig output_cfg;
    output_cfg.cells = {0, 1, 2, 3, 4};  // Первые 5 ячеек
    output_cfg.extract_every_n_steps = std::max(1, steps / 10);
    
    // ====================================================================
    // ВЫЧИСЛЕНИЕ НА CPU
    // ====================================================================
    auto result_cpu = compute_cpu(graph, initial, steps, feedback_type, &output_cfg);
    result.cpu_time_ms = result_cpu.elapsed_ms;
    
    #ifndef NO_CUDA
    // ====================================================================
    // ВЫЧИСЛЕНИЕ НА CUDA (если не определён флаг NO_CUDA)
    // ====================================================================
    /**
     * Запускаем ту же симуляцию на GPU и сравниваем результаты.
     * Если результаты не совпадают, это указывает на ошибку в CUDA коде!
     */
    auto result_cuda = compute_cuda(graph, initial, steps, feedback_type, &output_cfg);
    result.cuda_time_ms = result_cuda.elapsed_ms;
    
    // Проверка корректности: сравниваем выходные последовательности
    result.results_match = (result_cpu.output_sequence == result_cuda.output_sequence);
    
    // Вычисляем ускорение (speedup)
    // Значение > 1 означает, что CUDA быстрее
    // Значение < 1 означает, что CPU быстрее
    result.speedup = result.cpu_time_ms / result.cuda_time_ms;
    #else
    // Если CUDA недоступен, заполняем нулями
    result.cuda_time_ms = 0.0;
    result.speedup = 0.0;
    result.results_match = false;
    #endif
    
    return result;
}

// ====================================================================
// СОХРАНЕНИЕ РЕЗУЛЬТАТОВ В CSV ФАЙЛ
// ====================================================================
/**
 * Экспортирует результаты всех бенчмарков в CSV формат для:
 * - Построения графиков в Python (matplotlib)
 * - Анализа в Excel/LibreOffice
 * - Дальнейшей обработки данных
 * 
 * Формат CSV (Comma-Separated Values):
 * - Первая строка: заголовки столбцов
 * - Остальные строки: данные (одна строка = один тест)
 * - Разделитель: запятая
 * 
 * Параметры:
 * - results: вектор всех результатов бенчмарков
 * - filename: имя выходного файла
 */
void save_results_csv(const std::vector<BenchmarkResult>& results, const char* filename) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Ошибка открытия файла " << filename << "\n";
        return;
    }
    
    // ====================================================================
    // ЗАГОЛОВОК CSV
    // ====================================================================
    /**
     * Определяем имена столбцов:
     * - num_nodes: количество узлов
     * - num_edges: количество рёбер
     * - avg_degree: средняя степень узла
     * - steps: количество шагов
     * - feedback_type: тип функции (0 или 1)
     * - feedback_name: имя функции (XOR или MAJORITY)
     * - cpu_time_ms: время CPU
     * - cuda_time_ms: время CUDA
     * - speedup: ускорение
     * - results_match: корректность (true/false)
     */
    file << "num_nodes,num_edges,avg_degree,steps,feedback_type,feedback_name,"
         << "cpu_time_ms,cuda_time_ms,speedup,results_match\n";
    
    // ====================================================================
    // ЗАПИСЬ ДАННЫХ
    // ====================================================================
    /**
     * Для каждого теста записываем строку с результатами.
     * Используем setprecision для контроля точности чисел:
     * - avg_degree: 2 знака после запятой
     * - времена и speedup: 6 знаков после запятой
     */
    for (const auto& r : results) {
        // Вычисляем среднюю степень узла
        double avg_degree = (double)r.num_edges / r.num_nodes;
        
        file << r.num_nodes << ","
             << r.num_edges << ","
             << std::fixed << std::setprecision(2) << avg_degree << ","
             << r.steps << ","
             << r.feedback_type << ","
             << r.feedback_name << ","
             << std::fixed << std::setprecision(6) << r.cpu_time_ms << ","
             << r.cuda_time_ms << ","
             << r.speedup << ","
             << (r.results_match ? "true" : "false") << "\n";
    }
    
    file.close();
}

// ====================================================================
// ГЛАВНАЯ ФУНКЦИЯ
// ====================================================================
/**
 * Выполняет комплексное тестирование производительности:
 * 
 * План тестирования:
 * 1. Очень малые графы (50-500 узлов)
 *    - Проверка базовой корректности
 *    - На этих размерах CPU часто быстрее (накладные расходы CUDA)
 * 
 * 2. Малые графы (600-5K узлов)
 *    - Переходная зона
 *    - Ищем "точку перелома" где CUDA начинает побеждать
 * 
 * 3. Средние графы (6K-20K узлов)
 *    - CUDA должна быть значительно быстрее
 *    - Типичные размеры для реальных задач
 * 
 * 4. Большие графы (25K-100K узлов)
 *    - Демонстрация масштабируемости CUDA
 *    - Максимальное ускорение
 * 
 * 5. Очень большие графы (120K-300K узлов)
 *    - Стресс-тест
 *    - Проверка работы с большими объёмами памяти
 * 
 * 6. Тесты с функцией MAJORITY
 *    - Проверка, что выводы справедливы для разных функций
 * 
 * Результаты:
 * - Сохраняются в benchmark_results.csv
 * - Можно построить графики с помощью plot_benchmarks.py
 */
int main() {
    // Вектор для накопления всех результатов
    std::vector<BenchmarkResult> all_results;
    
    try {
        // ====================================================================
        // ОБЩИЕ ПАРАМЕТРЫ ТЕСТИРОВАНИЯ
        // ====================================================================
        /**
         * avg_degree = 5: каждый узел в среднем связан с 5 другими узлами
         * steps = 100: 100 шагов эволюции автомата
         * 
         * Эти параметры фиксированы для всех тестов, чтобы изолировать
         * влияние размера графа на производительность.
         */
        int avg_degree = 5;
        int steps = 100;
        
        // ====================================================================
        // ТЕСТИРОВАНИЕ ОЧЕНЬ МАЛЫХ ГРАФОВ (50-500 узлов)
        // ====================================================================
        /**
         * Цель: понять поведение на малых размерах
         * Ожидание: CPU быстрее из-за накладных расходов CUDA
         * (копирование данных GPU ↔ CPU)
         */
        std::vector<int> tiny_sizes = {50, 75, 100, 150, 200, 250, 300, 400, 500};
        for (int size : tiny_sizes) {
            auto result = benchmark_graph_size(size, avg_degree, steps, 0, "XOR");
            all_results.push_back(result);
        }
        
        // ====================================================================
        // ТЕСТИРОВАНИЕ МАЛЫХ ГРАФОВ (600-5K узлов)
        // ====================================================================
        /**
         * Цель: найти "точку перелома"
         * Ожидание: на каком-то размере CUDA начинает обгонять CPU
         */
        std::vector<int> small_sizes = {600, 800, 1000, 1500, 2000, 2500, 3000, 4000, 5000};
        for (int size : small_sizes) {
            auto result = benchmark_graph_size(size, avg_degree, steps, 0, "XOR");
            all_results.push_back(result);
        }
        
        // ====================================================================
        // ТЕСТИРОВАНИЕ СРЕДНИХ ГРАФОВ (6K-20K узлов)
        // ====================================================================
        /**
         * Цель: измерить преимущество CUDA на типичных размерах
         * Ожидание: CUDA значительно быстрее (ускорение 5-20x)
         */
        std::vector<int> medium_sizes = {6000, 7000, 8000, 9000, 10000, 12000, 15000, 18000, 20000};
        for (int size : medium_sizes) {
            auto result = benchmark_graph_size(size, avg_degree, steps, 0, "XOR");
            all_results.push_back(result);
        }
        
        // ====================================================================
        // ТЕСТИРОВАНИЕ БОЛЬШИХ ГРАФОВ (25K-100K узлов)
        // ====================================================================
        /**
         * Цель: показать масштабируемость CUDA
         * Ожидание: максимальное ускорение (20-100x)
         */
        std::vector<int> large_sizes = {25000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000};
        for (int size : large_sizes) {
            auto result = benchmark_graph_size(size, avg_degree, steps, 0, "XOR");
            all_results.push_back(result);
        }
        
        // ====================================================================
        // ТЕСТИРОВАНИЕ ОЧЕНЬ БОЛЬШИХ ГРАФОВ (120K-300K узлов)
        // ====================================================================
        /**
         * Цель: стресс-тест, проверка пределов
         * Внимание: может потребовать много памяти GPU!
         */
        std::vector<int> xlarge_sizes = {120000, 150000, 200000, 250000, 300000};
        for (int size : xlarge_sizes) {
            auto result = benchmark_graph_size(size, avg_degree, steps, 0, "XOR");
            all_results.push_back(result);
        }
        
        // ====================================================================
        // ТЕСТИРОВАНИЕ С ФУНКЦИЕЙ MAJORITY
        // ====================================================================
        /**
         * Цель: проверить, что выводы справедливы для другой функции
         * Функция MAJORITY более вычислительно сложная (сложение вместо XOR)
         * 
         * Ожидание: аналогичное поведение, возможно немного другие
         * пороговые значения для "точки перелома"
         */
        std::vector<int> majority_sizes = {100, 200, 500, 750, 1000, 1500, 2000, 3000, 5000, 
                                           7000, 10000, 15000, 20000, 30000, 50000, 70000, 
                                           100000, 150000, 200000, 300000};
        for (int size : majority_sizes) {
            auto result = benchmark_graph_size(size, avg_degree, steps, 1, "MAJORITY");
            all_results.push_back(result);
        }
        
        // ====================================================================
        // СОХРАНЕНИЕ РЕЗУЛЬТАТОВ
        // ====================================================================
        /**
         * Все результаты сохраняются в CSV файл.
         * Этот файл можно использовать для:
         * - Построения графиков (plot_benchmarks.py)
         * - Анализа в таблицах
         * - Сравнения разных запусков
         */
        save_results_csv(all_results, "benchmark_results.csv");
        
    } catch (const std::exception& e) {
        // Обработка любых исключений
        std::cerr << "\n✗ Ошибка: " << e.what() << "\n";
        return 1;
    }
    
    return 0;
}
