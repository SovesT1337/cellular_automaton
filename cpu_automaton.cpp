/**
 * ====================================================================
 * CPU РЕАЛИЗАЦИЯ КЛЕТОЧНОГО АВТОМАТА
 * ====================================================================
 * 
 * Этот файл содержит:
 * 1. Генератор случайных графов
 * 2. CPU-версию симулятора клеточного автомата
 * 
 * CPU-версия служит эталонной реализацией для проверки
 * корректности CUDA-версии и используется для сравнения
 * производительности.
 */

#include "cellular_automaton.h"
#include <chrono>
#include <random>

// ====================================================================
// ГЕНЕРАТОР СЛУЧАЙНЫХ ГРАФОВ
// ====================================================================
/**
 * Создаёт случайный граф с заданными параметрами.
 * 
 * Алгоритм генерации:
 * 1. Для каждого узла i:
 *    a) Генерируем случайную степень (от 1 до 2*avg_degree-1)
 *    b) Для каждого ребра выбираем случайного соседа
 *    c) Исключаем петли (рёбра узла к самому себе)
 * 2. Конвертируем в формат CSR для эффективного хранения
 * 
 * Особенности:
 * - Граф может быть направленным (рёбра односторонние)
 * - Могут быть дубликаты рёбер (одинаковые соседи)
 * - Используется seed для воспроизводимости результатов
 */
Graph generate_random_graph(int num_nodes, int avg_degree, unsigned int seed) {
    Graph g;
    g.num_nodes = num_nodes;
    g.row_ptr.resize(num_nodes + 1);  // Размер n+1 для CSR формата
    
    // Инициализация генератора случайных чисел
    std::mt19937 rng(seed);  // Mersenne Twister генератор
    
    // Распределение для степеней узлов (от 1 до 2*avg_degree-1)
    // Это даёт среднюю степень примерно равную avg_degree
    std::uniform_int_distribution<int> degree_dist(1, avg_degree * 2 - 1);
    
    // Распределение для выбора случайных соседей
    std::uniform_int_distribution<int> node_dist(0, num_nodes - 1);
    
    // Временное представление графа в виде списков смежности
    // adj[i] = список соседей узла i
    std::vector<std::vector<int>> adj(num_nodes);
    
    // Генерация рёбер для каждого узла
    for (int i = 0; i < num_nodes; i++) {
        int degree = degree_dist(rng);  // Случайная степень узла
        for (int j = 0; j < degree; j++) {
            int neighbor = node_dist(rng);  // Случайный сосед
            // Исключаем петли (рёбра к самому себе)
            if (neighbor != i) {
                adj[i].push_back(neighbor);
            }
        }
    }
    
    // ====================================================================
    // КОНВЕРТАЦИЯ В CSR (Compressed Sparse Row) ФОРМАТ
    // ====================================================================
    /**
     * CSR формат компактно хранит разреженный граф:
     * - row_ptr[i] = индекс начала списка соседей узла i в col_idx
     * - row_ptr[i+1] = индекс конца списка соседей узла i
     * - col_idx = непрерывный массив всех соседей всех узлов
     * 
     * Пример: если узел 0 имеет соседей [1,2], узел 1 имеет [0],
     *         то col_idx = [1, 2, 0], row_ptr = [0, 2, 3]
     */
    g.row_ptr[0] = 0;  // Первый узел начинается с индекса 0
    for (int i = 0; i < num_nodes; i++) {
        // row_ptr[i+1] = где заканчивается список соседей узла i
        g.row_ptr[i + 1] = g.row_ptr[i] + adj[i].size();
        
        // Добавляем всех соседей узла i в col_idx
        for (int n : adj[i]) {
            g.col_idx.push_back(n);
        }
    }
    g.num_edges = g.col_idx.size();  // Общее количество рёбер
    
    return g;
}

// ====================================================================
// CPU ВЫЧИСЛЕНИЕ КЛЕТОЧНОГО АВТОМАТА
// ====================================================================
/**
 * Симулирует эволюцию клеточного автомата на CPU.
 * 
 * Архитектура:
 * - Использует технику "двойной буферизации"
 * - current = текущее состояние
 * - next = следующее состояние (вычисляется)
 * - После каждого шага current и next меняются местами
 * 
 * Это предотвращает проблему одновременного чтения/записи:
 * мы читаем из current и пишем в next, затем меняем их роли.
 * 
 * Сложность:
 * - Время: O(steps × num_edges) - для каждого шага проходим все рёбра
 * - Память: O(num_nodes) - храним только текущее и следующее состояние
 */
ComputeResult compute_cpu(const Graph& graph, const std::vector<uint8_t>& initial_state, 
                          int steps, int feedback_type, const OutputConfig* output_cfg) {
    ComputeResult result;
    int n = graph.num_nodes;
    
    // Буферы для состояний (двойная буферизация)
    std::vector<uint8_t> current = initial_state;  // Текущее состояние
    std::vector<uint8_t> next(n);                  // Следующее состояние
    
    // Буфер для временного хранения состояний соседей
    // Размер 256 должен быть достаточным для большинства графов
    // (если степень узла > 256, будет работать, но менее эффективно)
    std::vector<uint8_t> neighbors_buf(256);
    
    // Сохраняем начальное состояние в историю
    result.history.push_back(current);
    
    // ====================================================================
    // ИЗВЛЕЧЕНИЕ НАЧАЛЬНЫХ ЗНАЧЕНИЙ ДЛЯ ВЫХОДНОЙ ПОСЛЕДОВАТЕЛЬНОСТИ
    // ====================================================================
    /**
     * Если задана конфигурация выхода, извлекаем значения из
     * выбранных ячеек (cells) в начальном состоянии.
     */
    if (output_cfg && !output_cfg->cells.empty()) {
        for (int cell_idx : output_cfg->cells) {
            // Проверяем валидность индекса
            if (cell_idx >= 0 && cell_idx < n) {
                result.output_sequence.push_back(current[cell_idx]);
            }
        }
    }
    
    // Начинаем замер времени выполнения
    auto start = std::chrono::high_resolution_clock::now();
    
    // ====================================================================
    // ГЛАВНЫЙ ЦИКЛ СИМУЛЯЦИИ
    // ====================================================================
    /**
     * На каждом шаге:
     * 1. Для каждого узла собираем состояния его соседей
     * 2. Применяем функцию обратной связи
     * 3. Записываем результат в новое состояние
     * 4. Меняем буферы местами
     * 5. Сохраняем историю и выходную последовательность
     */
    for (int step = 0; step < steps; step++) {
        
        // Проходим по всем узлам графа
        for (int i = 0; i < n; i++) {
            // ====================================================================
            // ИЗВЛЕЧЕНИЕ СОСЕДЕЙ УЗЛА I ИЗ CSR ПРЕДСТАВЛЕНИЯ
            // ====================================================================
            /**
             * В CSR формате соседи узла i находятся в диапазоне:
             * col_idx[row_ptr[i] : row_ptr[i+1]]
             */
            int start_idx = graph.row_ptr[i];      // Начало списка соседей
            int end_idx = graph.row_ptr[i + 1];    // Конец списка соседей
            int degree = end_idx - start_idx;      // Количество соседей (степень узла)
            
            // Копируем состояния всех соседей в буфер
            for (int j = 0; j < degree; j++) {
                int neighbor_idx = graph.col_idx[start_idx + j];  // Индекс соседа
                neighbors_buf[j] = current[neighbor_idx];         // Состояние соседа
            }
            
            // ====================================================================
            // ПРИМЕНЕНИЕ ФУНКЦИИ ОБРАТНОЙ СВЯЗИ
            // ====================================================================
            /**
             * Вычисляем новое состояние узла i на основе состояний соседей.
             * 
             * feedback_type:
             *   0 = XOR (исключающее ИЛИ всех соседей)
             *   1 = MAJORITY (правило большинства)
             */
            if (feedback_type == 1) {
                next[i] = feedback_majority(neighbors_buf.data(), degree);
            } else {
                next[i] = feedback_xor(neighbors_buf.data(), degree);
            }
        }
        
        // ====================================================================
        // ОБНОВЛЕНИЕ СОСТОЯНИЯ (swap буферов)
        // ====================================================================
        /**
         * Меняем указатели местами вместо копирования данных.
         * Это очень быстрая операция O(1).
         * После swap:
         *   current = то, что было next (новое состояние)
         *   next = то, что было current (будет перезаписано на следующем шаге)
         */
        std::swap(current, next);
        
        // Сохраняем текущее состояние в историю
        result.history.push_back(current);
        
        // ====================================================================
        // ИЗВЛЕЧЕНИЕ ВЫХОДНОЙ ПОСЛЕДОВАТЕЛЬНОСТИ
        // ====================================================================
        /**
         * Если задана конфигурация выхода и текущий шаг кратен
         * extract_every_n_steps, извлекаем значения из выбранных ячеек.
         * 
         * Это позволяет разредить выход (не на каждом шаге), что
         * экономит память для длинных симуляций.
         */
        if (output_cfg && !output_cfg->cells.empty()) {
            // Проверяем, нужно ли извлекать на этом шаге
            if ((step + 1) % output_cfg->extract_every_n_steps == 0) {
                for (int cell_idx : output_cfg->cells) {
                    if (cell_idx >= 0 && cell_idx < n) {
                        result.output_sequence.push_back(current[cell_idx]);
                    }
                }
            }
        }
    }
    
    // ====================================================================
    // ЗАВЕРШЕНИЕ И ВОЗВРАТ РЕЗУЛЬТАТОВ
    // ====================================================================
    
    // Останавливаем таймер и вычисляем время выполнения
    auto end = std::chrono::high_resolution_clock::now();
    result.elapsed_ms = std::chrono::duration<double, std::milli>(end - start).count();
    
    // Сохраняем финальное состояние
    result.final_state = current;
    
    return result;
}
