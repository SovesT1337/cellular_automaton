/**
 * ====================================================================
 * ОБОБЩЕННЫЙ КЛЕТОЧНЫЙ АВТОМАТ
 * ====================================================================
 * 
 * Этот заголовочный файл содержит определения структур данных и
 * функций для реализации клеточного автомата, который работает
 * на произвольном графе с различными функциями обратной связи.
 * 
 * Основная идея:
 * - Каждый узел графа представляет собой ячейку автомата (0 или 1)
 * - На каждом шаге состояние ячейки обновляется на основе
 *   состояний её соседей (связанных узлов)
 * - Функция обратной связи определяет правило обновления
 */

#ifndef CELLULAR_AUTOMATON_H
#define CELLULAR_AUTOMATON_H

#include <vector>
#include <cstdint>

// ====================================================================
// СТРУКТУРА ГРАФА В ФОРМАТЕ CSR (Compressed Sparse Row)
// ====================================================================
/**
 * CSR - это эффективный способ хранения разреженных графов.
 * Преимущества:
 * - Экономия памяти (не хранятся отсутствующие рёбра)
 * - Быстрый доступ к соседям узла
 * - Хорошо подходит для параллельных вычислений на GPU
 * 
 * Принцип работы:
 * - row_ptr[i] указывает на начало списка соседей i-го узла
 * - row_ptr[i+1] указывает на конец списка соседей i-го узла
 * - Соседи узла i находятся в col_idx[row_ptr[i] : row_ptr[i+1]]
 * 
 * Пример: граф с 3 узлами
 *   Узел 0 -> [1, 2]
 *   Узел 1 -> [0]
 *   Узел 2 -> [0, 1]
 * 
 *   row_ptr = [0, 2, 3, 5]  (размер: num_nodes + 1)
 *   col_idx = [1, 2, 0, 0, 1]  (размер: num_edges)
 */
struct Graph {
    std::vector<int> row_ptr;    // Указатели на начало списков соседей (размер: num_nodes + 1)
    std::vector<int> col_idx;    // Индексы соседних узлов (размер: num_edges)
    int num_nodes;               // Общее количество узлов в графе
    int num_edges;               // Общее количество рёбер в графе
};

// ====================================================================
// СТРУКТУРА РЕЗУЛЬТАТА ВЫЧИСЛЕНИЯ
// ====================================================================
/**
 * Содержит все результаты симуляции клеточного автомата:
 * 
 * - final_state: финальное состояние всех ячеек после всех шагов
 * - history: полная история изменений состояний на каждом шаге
 *   (может занимать много памяти для больших графов!)
 * - output_sequence: последовательность значений из выбранных ячеек
 *   (используется для извлечения битовой последовательности)
 * - elapsed_ms: время выполнения в миллисекундах
 */
struct ComputeResult {
    std::vector<uint8_t> final_state;              // Состояние всех узлов после симуляции
    std::vector<std::vector<uint8_t>> history;     // История состояний на каждом шаге
    std::vector<uint8_t> output_sequence;          // Битовая последовательность из выбранных ячеек
    double elapsed_ms;                             // Время выполнения (мс)
};

// ====================================================================
// КОНФИГУРАЦИЯ ВЫХОДНОЙ ПОСЛЕДОВАТЕЛЬНОСТИ
// ====================================================================
/**
 * Определяет, как извлекать выходную битовую последовательность
 * из состояний автомата.
 * 
 * Применение:
 * - Генерация псевдослучайных последовательностей
 * - Криптография (генерация ключевых потоков)
 * - Тестирование свойств автомата
 * 
 * Параметры:
 * - cells: список индексов ячеек, из которых извлекаются биты
 *   (например, [0, 1, 2] - первые три ячейки)
 * - extract_every_n_steps: частота извлечения
 *   (1 = на каждом шаге, 10 = каждый 10-й шаг)
 */
struct OutputConfig {
    std::vector<int> cells;           // Индексы ячеек для выходной последовательности
    int extract_every_n_steps;        // Извлекать каждые N шагов (для разреживания выборки)
    
    OutputConfig() : extract_every_n_steps(1) {}
};

// ====================================================================
// ФУНКЦИИ ОБРАТНОЙ СВЯЗИ (ПРАВИЛА ОБНОВЛЕНИЯ)
// ====================================================================
/**
 * Функции обратной связи определяют, как вычисляется новое состояние
 * ячейки на основе состояний её соседей.
 * 
 * Входные данные:
 * - neighbors: массив состояний соседних ячеек (каждое 0 или 1)
 * - count: количество соседей
 * 
 * Выход: новое состояние ячейки (0 или 1)
 */

/**
 * XOR (исключающее ИЛИ) - линейная функция
 * 
 * Принцип:
 * - Вычисляет XOR всех соседей
 * - Результат: 1 если нечётное количество единиц, иначе 0
 * 
 * Свойства:
 * - Линейная операция (важно для криптографии)
 * - Быстрое вычисление
 * - Хорошо распараллеливается
 * 
 * Пример:
 *   Соседи: [1, 0, 1] -> 1 XOR 0 XOR 1 = 0
 *   Соседи: [1, 1, 1] -> 1 XOR 1 XOR 1 = 1
 */
inline uint8_t feedback_xor(const uint8_t* neighbors, int count) {
    uint8_t result = 0;
    for (int i = 0; i < count; i++) {
        result ^= neighbors[i];  // Побитовое XOR
    }
    return result;
}

/**
 * MAJORITY (правило большинства) - нелинейная функция
 * 
 * Принцип:
 * - Подсчитывает количество единиц среди соседей
 * - Возвращает 1, если единиц больше половины, иначе 0
 * 
 * Свойства:
 * - Нелинейная операция
 * - Создаёт более сложную динамику
 * - Устойчива к шуму (один бит не меняет результат)
 * 
 * Пример:
 *   Соседи: [1, 0, 1] -> сумма=2, 2 > 3/2=1 -> результат: 1
 *   Соседи: [1, 0, 0] -> сумма=1, 1 > 3/2=1 -> результат: 0
 */
inline uint8_t feedback_majority(const uint8_t* neighbors, int count) {
    int sum = 0;
    // Подсчитываем количество единиц
    for (int i = 0; i < count; i++) {
        sum += neighbors[i];
    }
    // Проверяем, больше ли половины
    return (sum > count / 2) ? 1 : 0;
}

// ====================================================================
// ГЕНЕРАТОР СЛУЧАЙНЫХ ГРАФОВ
// ====================================================================
/**
 * Создаёт случайный граф с заданными параметрами.
 * 
 * Параметры:
 * - num_nodes: количество узлов в графе
 * - avg_degree: средняя степень узла (среднее количество соседей)
 * - seed: зерно для генератора случайных чисел (для воспроизводимости)
 * 
 * Алгоритм:
 * 1. Для каждого узла генерируется случайная степень (число соседей)
 * 2. Для каждого соседа выбирается случайный узел из графа
 * 3. Граф конвертируется в формат CSR для эффективного хранения
 * 
 * Возвращает: структуру Graph в формате CSR
 */
Graph generate_random_graph(int num_nodes, int avg_degree, unsigned int seed);

// ====================================================================
// ФУНКЦИИ ВЫЧИСЛЕНИЯ АВТОМАТА
// ====================================================================

/**
 * Вычисление на CPU (центральном процессоре)
 * 
 * Параметры:
 * - graph: граф связей в формате CSR
 * - initial_state: начальное состояние всех ячеек (вектор 0 и 1)
 * - steps: количество шагов эволюции
 * - feedback_type: тип функции обратной связи (0=XOR, 1=MAJORITY)
 * - output_cfg: конфигурация выходной последовательности (опционально)
 * 
 * Алгоритм:
 * 1. На каждом шаге для каждого узла:
 *    a) Получить состояния всех соседей
 *    b) Применить функцию обратной связи
 *    c) Записать новое состояние
 * 2. Перейти к следующему шагу
 * 
 * Особенности CPU версии:
 * - Последовательная обработка узлов
 * - Простая реализация
 * - Хорошо работает на малых графах (<1000 узлов)
 * 
 * Возвращает: ComputeResult с результатами и временем выполнения
 */
ComputeResult compute_cpu(const Graph& graph, const std::vector<uint8_t>& initial_state, 
                          int steps, int feedback_type, const OutputConfig* output_cfg = nullptr);

/**
 * Вычисление на CUDA (графическом процессоре)
 * 
 * Параметры: те же, что и у compute_cpu
 * 
 * Алгоритм:
 * 1. Копирование данных на GPU
 * 2. Запуск параллельных вычислений:
 *    - Каждый узел обрабатывается отдельной нитью GPU
 *    - Все узлы обновляются одновременно
 * 3. Копирование результатов обратно на CPU
 * 
 * Особенности CUDA версии:
 * - Массивная параллельность (тысячи нитей одновременно)
 * - Накладные расходы на копирование данных GPU ↔ CPU
 * - Эффективна на больших графах (>5000 узлов)
 * - Требует NVIDIA GPU с поддержкой CUDA
 * 
 * Преимущества:
 * - Ускорение до 100x на больших графах
 * - Масштабируемость для миллионов узлов
 * 
 * Возвращает: ComputeResult с результатами и временем выполнения
 */
ComputeResult compute_cuda(const Graph& graph, const std::vector<uint8_t>& initial_state, 
                           int steps, int feedback_type, const OutputConfig* output_cfg = nullptr);

#endif // CELLULAR_AUTOMATON_H
