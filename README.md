# Обобщенный клеточный автомат - CPU vs CUDA

Вычисление выходной последовательности обобщенного клеточного автомата по заданному графу и функции обратной связи.

## Теория

### Клеточный автомат (КА)
Дискретная вычислительная модель:
- **Сетка ячеек** - каждая имеет состояние (0 или 1)
- **Правило перехода** - определяет новое состояние на основе соседей
- **Дискретное время** - все ячейки обновляются синхронно

### Обобщенный КА
Отличия от классического:
- Топология связей задается **произвольным графом** (не только регулярная сетка)
- Функция обратной связи может быть **произвольной**
- Поддержка **N-мерных** регулярных решеток

## Структура проекта

```
cellular_automaton/
├── cellular_automaton.h   # Структуры данных и интерфейсы
├── cpu_automaton.cpp      # CPU реализация (последовательная)
├── cuda_automaton.cu      # CUDA реализация (параллельная на GPU)
├── main.cpp               # Бенчмарк CPU vs CUDA
├── main_cpu.cpp           # Только CPU версия
└── Makefile
```

## Сборка

```bash
# С CUDA (требуется NVIDIA GPU и CUDA Toolkit)
make
./cellular_automaton

# Только CPU
make cpu_only
./cellular_automaton_cpu
```

## N-мерные решетки

Поддерживаются решетки произвольной размерности:

| Размерность | Пример | Соседи (фон Нейман) | Соседи (Мур) |
|-------------|--------|---------------------|--------------|
| 1D | {1000} | 2 | 2 |
| 2D | {100, 100} | 4 | 8 |
| 3D | {50, 50, 50} | 6 | 26 |
| 4D | {20, 20, 20, 20} | 8 | 80 |
| ND | {d1, d2, ..., dN} | 2N | 3^N - 1 |

### Типы окрестностей

**Фон Нейман**: ортогональные соседи (±1 по одной оси)
```
    [1]
 [1][X][1]
    [1]
```

**Мур**: все соседи включая диагональные
```
 [1][1][1]
 [1][X][1]
 [1][1][1]
```

## Функции обратной связи

| Тип | Описание | Применение |
|-----|----------|------------|
| XOR | Исключающее ИЛИ всех соседей | Криптография, LFSR |
| Majority | Большинство голосов | Консенсус, сглаживание |
| Rule 110 | Универсальный 1D КА | Вычисления (Тьюринг-полный) |

## Формат графа (CSR)

Compressed Sparse Row - эффективный формат для GPU:

```
Граф: 0->1, 0->2, 1->2, 2->0

row_ptr = [0, 2, 3, 4]   # Начало списка соседей
col_idx = [1, 2, 2, 0]   # Индексы соседей

Соседи вершины i: col_idx[row_ptr[i] : row_ptr[i+1]]
```

## Выходные метрики

- **Время выполнения** (ms)
- **Ускорение** (speedup = CPU_time / CUDA_time)
- **Проверка корректности** (совпадение результатов)
- **Пропускная способность** (cells/s)

## Пример вывода

```
=== 3D Grid: 100x100x100 ===
Total cells: 1000000
Periodic: No
Neighborhood: von Neumann
Graph: 1000000 nodes, 5940000 edges
Avg degree: 5.9
CPU time:  180.225 ms
CUDA time: 12.453 ms
Speedup:   14.47x
Throughput CUDA: 4.01e+09 cells/s
```

## Параллелизм CUDA

- Каждая ячейка = 1 поток (thread)
- Потоки группируются в блоки по 256
- GPU обрабатывает миллионы ячеек одновременно

```
┌─────────────────────────────────────────┐
│ Grid (все блоки)                        │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐    │
│  │ Block 0 │ │ Block 1 │ │ Block N │    │
│  │ 256 thr │ │ 256 thr │ │ 256 thr │    │
│  └─────────┘ └─────────┘ └─────────┘    │
└─────────────────────────────────────────┘
```
