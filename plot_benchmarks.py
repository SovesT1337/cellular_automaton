#!/usr/bin/env python3
"""
====================================================================
СКРИПТ ДЛЯ ВИЗУАЛИЗАЦИИ РЕЗУЛЬТАТОВ БЕНЧМАРКОВ
====================================================================

Этот Python скрипт:
1. Загружает результаты из benchmark_results.csv
2. Строит графики сравнения CPU vs CUDA
3. Вычисляет статистику производительности
4. Находит "точку перелома" (где CUDA становится быстрее)
5. Сохраняет графики в PNG файл

Требования:
- Python 3.x
- matplotlib (pip install matplotlib)
- CSV файл с результатами бенчмарков

Использование:
    python3 plot_benchmarks.py

Результат:
- benchmark_plots.png - графики производительности
- Статистика в консоли
"""

import csv
import matplotlib.pyplot as plt

# ====================================================================
# НАСТРОЙКА СТИЛЯ ГРАФИКОВ
# ====================================================================
"""
Используем стиль seaborn для красивых графиков:
- Сетка для лучшей читаемости
- Приятные цвета
- Большой размер для деталей
"""
plt.style.use('seaborn-v0_8-darkgrid')
plt.rcParams['figure.figsize'] = (16, 6)  # Широкий формат для двух графиков
plt.rcParams['font.size'] = 11

# ====================================================================
# ЗАГРУЗКА ДАННЫХ ИЗ CSV ФАЙЛА
# ====================================================================
"""
Читаем CSV файл, созданный C++ программой.
Каждая строка = один тест.

Структура данных:
- num_nodes: количество узлов в графе
- num_edges: количество рёбер
- avg_degree: средняя степень узла
- steps: количество шагов симуляции
- feedback_type: тип функции (0=XOR, 1=MAJORITY)
- feedback_name: имя функции
- cpu_time_ms: время CPU в миллисекундах
- cuda_time_ms: время CUDA в миллисекундах
- speedup: ускорение (cpu/cuda)
- results_match: корректность (true/false)
"""
data = []
with open('benchmark_results.csv', 'r') as f:
    reader = csv.DictReader(f)  # Автоматически использует первую строку как заголовки
    for row in reader:
        # Преобразуем строки в нужные типы данных
        data.append({
            'num_nodes': int(row['num_nodes']),
            'num_edges': int(row['num_edges']),
            'avg_degree': float(row['avg_degree']),
            'steps': int(row['steps']),
            'feedback_type': int(row['feedback_type']),
            'feedback_name': row['feedback_name'],
            'cpu_time_ms': float(row['cpu_time_ms']),
            'cuda_time_ms': float(row['cuda_time_ms']),
            'speedup': float(row['speedup']),
            'results_match': row['results_match'] == 'true'
        })

print(f"Загружено {len(data)} записей")

# ====================================================================
# ФУНКЦИЯ ФИЛЬТРАЦИИ ДАННЫХ
# ====================================================================
"""
Выбирает подмножество данных по критериям:
- feedback_type: тип функции (0 или 1)
- steps: количество шагов (по умолчанию 100)
- max_nodes: максимальный размер графа

Возвращает отсортированный список по возрастанию num_nodes.
Это важно для правильного построения линий на графиках.
"""
def filter_data(data, feedback_type, steps=100, max_nodes=1000000):
    """
    Фильтрует данные по типу функции и количеству шагов.
    
    Параметры:
        data: список всех результатов
        feedback_type: 0 для XOR, 1 для MAJORITY
        steps: количество шагов (для изоляции этой переменной)
        max_nodes: максимальный размер графа (для ограничения диапазона)
    
    Возвращает:
        Отсортированный список результатов
    """
    return sorted(
        [row for row in data 
         if row['feedback_type'] == feedback_type 
         and row['steps'] == steps 
         and row['num_nodes'] <= max_nodes],
        key=lambda x: x['num_nodes']  # Сортировка по размеру графа
    )

# ====================================================================
# ФИЛЬТРАЦИЯ ДАННЫХ ДЛЯ ДВУХ ФУНКЦИЙ
# ====================================================================
"""
Разделяем данные на два набора:
- xor_data: результаты для функции XOR
- maj_data: результаты для функции MAJORITY

Это позволит построить отдельные графики для каждой функции.
"""
xor_data = filter_data(data, feedback_type=0)  # XOR функция
maj_data = filter_data(data, feedback_type=1)  # MAJORITY функция

# ====================================================================
# СОЗДАНИЕ ФИГУРЫ С ДВУМЯ ГРАФИКАМИ
# ====================================================================
"""
Создаём фигуру с двумя подграфиками (1 строка, 2 столбца):
- Левый график: XOR функция
- Правый график: MAJORITY функция

Это позволяет наглядно сравнить поведение для разных функций.
"""
fig, axes = plt.subplots(1, 2, figsize=(16, 6))
fig.suptitle('Сравнение производительности CPU vs CUDA\nОбобщенный клеточный автомат', 
             fontsize=16, fontweight='bold')

# ============================================================================
# ГРАФИК 1: ФУНКЦИЯ XOR
# ============================================================================
"""
Строим график зависимости времени выполнения от размера графа
для функции XOR.

Элементы графика:
- Ось X: количество узлов графа
- Ось Y: время выполнения в миллисекундах
- Две линии: CPU (синяя) и CUDA (фиолетовая)

Цель:
- Визуализировать, при каком размере CUDA начинает обгонять CPU
- Показать масштабируемость обеих реализаций
"""
ax1 = axes[0]

# Извлекаем данные для графика
xor_nodes = [row['num_nodes'] for row in xor_data]        # Ось X
xor_cpu_times = [row['cpu_time_ms'] for row in xor_data]  # Линия CPU
xor_cuda_times = [row['cuda_time_ms'] for row in xor_data] # Линия CUDA

# ====================================================================
# РИСУЕМ ЛИНИИ
# ====================================================================
"""
Стиль линий:
- CPU: синий цвет (#2E86AB), круглые маркеры (o)
- CUDA: фиолетовый (#A23B72), квадратные маркеры (s)
- Оба: сплошная линия (-), толщина 1.5

Маркеры помогают различать точки данных.
Контур маркеров (чёрный) улучшает видимость.
"""
ax1.plot(xor_nodes, xor_cpu_times, 
         'o-', color='#2E86AB', linewidth=1.5, markersize=6, label='CPU', 
         markeredgewidth=0.5, markeredgecolor='black')
ax1.plot(xor_nodes, xor_cuda_times, 
         's-', color='#A23B72', linewidth=1.5, markersize=6, label='CUDA', 
         markeredgewidth=0.5, markeredgecolor='black')

# Настройка осей и заголовков
ax1.set_xlabel('Количество узлов графа', fontsize=13, fontweight='bold')
ax1.set_ylabel('Время выполнения (мс)', fontsize=13, fontweight='bold')
ax1.set_title('Функция обратной связи: XOR\n(100 шагов эволюции)', 
              fontsize=14, fontweight='bold')
ax1.legend(fontsize=12, loc='upper left', framealpha=0.9)
ax1.grid(True, alpha=0.3, linestyle='--')  # Полупрозрачная пунктирная сетка

# ============================================================================
# ГРАФИК 2: ФУНКЦИЯ MAJORITY
# ============================================================================
"""
Аналогичный график для функции MAJORITY.

Цель сравнения двух функций:
- Проверить, что выводы о производительности универсальны
- Оценить влияние сложности функции на ускорение
- MAJORITY более вычислительно сложная (сложение vs XOR)
"""
ax2 = axes[1]

# Извлекаем данные для графика
maj_nodes = [row['num_nodes'] for row in maj_data]
maj_cpu_times = [row['cpu_time_ms'] for row in maj_data]
maj_cuda_times = [row['cuda_time_ms'] for row in maj_data]

# Рисуем линии (тот же стиль, что и для XOR)
ax2.plot(maj_nodes, maj_cpu_times, 
         'o-', color='#2E86AB', linewidth=1.5, markersize=6, label='CPU', 
         markeredgewidth=0.5, markeredgecolor='black')
ax2.plot(maj_nodes, maj_cuda_times, 
         's-', color='#A23B72', linewidth=1.5, markersize=6, label='CUDA', 
         markeredgewidth=0.5, markeredgecolor='black')

# Настройка осей и заголовков
ax2.set_xlabel('Количество узлов графа', fontsize=13, fontweight='bold')
ax2.set_ylabel('Время выполнения (мс)', fontsize=13, fontweight='bold')
ax2.set_title('Функция обратной связи: MAJORITY\n(100 шагов эволюции)', 
              fontsize=14, fontweight='bold')
ax2.legend(fontsize=12, loc='upper left', framealpha=0.9)
ax2.grid(True, alpha=0.3, linestyle='--')

# ====================================================================
# СОХРАНЕНИЕ ГРАФИКОВ
# ====================================================================
"""
Сохраняем графики в PNG файл высокого качества:
- dpi=300: высокое разрешение (подходит для печати)
- bbox_inches='tight': обрезка лишних полей
- tight_layout(): автоматическая оптимизация расположения элементов
"""
plt.tight_layout()
plt.savefig('benchmark_plots.png', dpi=300, bbox_inches='tight')
print("\n✓ Графики сохранены в файл: benchmark_plots.png")

# ============================================================================
# СТАТИСТИКА ПРОИЗВОДИТЕЛЬНОСТИ
# ============================================================================
"""
Вычисляем и выводим статистику для анализа результатов:

1. Общая статистика:
   - Сколько тестов выполнено
   - В скольких случаях CUDA быстрее
   - В скольких случаях CPU быстрее

2. Максимальное ускорение:
   - Наибольший коэффициент speedup
   - При каких параметрах достигнут

3. Пороговый размер:
   - При каком размере графа CUDA начинает обгонять CPU
   - Критически важно для выбора технологии
"""
print("\n" + "="*70)
print("СТАТИСТИКА ПРОИЗВОДИТЕЛЬНОСТИ")
print("="*70)

# Подсчёт общих метрик
total_tests = len(data)
cuda_faster = len([row for row in data if row['speedup'] > 1])  # speedup > 1 = CUDA быстрее
cpu_faster = len([row for row in data if row['speedup'] < 1])   # speedup < 1 = CPU быстрее

print(f"\nВсего тестов: {total_tests}")
print(f"CUDA быстрее: {cuda_faster} ({100*cuda_faster/total_tests:.1f}%)")
print(f"CPU быстрее:  {cpu_faster} ({100*cpu_faster/total_tests:.1f}%)")

# Находим максимальное ускорение
max_speedup = max(row['speedup'] for row in data)
max_speedup_row = [row for row in data if row['speedup'] == max_speedup][0]
print(f"\nМаксимальное ускорение CUDA: {max_speedup:.2f}x")
print(f"  Граф: {max_speedup_row['num_nodes']} узлов, "
      f"{max_speedup_row['steps']} шагов, {max_speedup_row['feedback_name']}")

# ====================================================================
# ПОИСК "ТОЧКИ ПЕРЕЛОМА"
# ====================================================================
"""
"Точка перелома" - это минимальный размер графа, при котором
CUDA начинает обгонять CPU (speedup > 1).

Это критически важная метрика:
- Если ваш граф меньше этого порога, используйте CPU
- Если больше - используйте CUDA

Пороговое значение зависит от:
- Архитектуры GPU
- Накладных расходов на копирование данных
- Сложности функции обратной связи
"""
threshold_data = [row for row in data if row['speedup'] > 1 and row['steps'] == 100]
if threshold_data:
    threshold = min(row['num_nodes'] for row in threshold_data)
    print(f"\nПороговый размер графа (когда CUDA становится быстрее):")
    print(f"  ~{threshold} узлов (при 100 шагах)")

print("\n" + "="*70)

# ============================================================================
# СРАВНИТЕЛЬНАЯ ТАБЛИЦА XOR VS MAJORITY
# ============================================================================
"""
Выводим таблицу с прямым сравнением времён выполнения
для обеих функций на ключевых размерах графов.

Цель:
- Оценить влияние сложности функции на производительность
- Увидеть конкретные числа для важных размеров
- Упростить выбор технологии для конкретной задачи

Формат таблицы:
Размер | XOR CPU | XOR CUDA | MAJ CPU | MAJ CUDA
"""
print("\nСРАВНЕНИЕ ФУНКЦИЙ (при 100 шагах):")
print("-" * 70)
print(f"{'Размер':<15} {'XOR CPU':<12} {'XOR CUDA':<12} {'MAJ CPU':<12} {'MAJ CUDA':<12}")
print("-" * 70)

# Выбираем ключевые размеры для сравнения
# От малых (100) до очень больших (500K)
for size in [100, 1000, 10000, 50000, 100000, 200000, 500000]:
    # Ищем результаты для этого размера
    xor_row = [row for row in xor_data if row['num_nodes'] == size]
    maj_row = [row for row in maj_data if row['num_nodes'] == size]
    
    # Если есть данные для обеих функций, выводим строку таблицы
    if xor_row and maj_row:
        xor_cpu = xor_row[0]['cpu_time_ms']
        xor_cuda = xor_row[0]['cuda_time_ms']
        maj_cpu = maj_row[0]['cpu_time_ms']
        maj_cuda = maj_row[0]['cuda_time_ms']
        
        # Форматируем размер (100 узлов или 1K узлов)
        size_str = f"{size//1000}K узлов" if size >= 1000 else f"{size} узлов"
        print(f"{size_str:<15} {xor_cpu:>10.3f}мс {xor_cuda:>10.3f}мс {maj_cpu:>10.3f}мс {maj_cuda:>10.3f}мс")

print("\n✓ Графики успешно построены!\n")

# ====================================================================
# ОТОБРАЖЕНИЕ ГРАФИКОВ
# ====================================================================
"""
Показываем графики в интерактивном окне.
Пользователь может:
- Приближать/отдалять
- Сохранить в другой формат
- Изучить конкретные точки данных
"""
plt.show()
